## 目标
今天的目标是知道 Middleware 是如何作用的. 租户层在 Frontend 中是如何作用的.

## Thanos QueryFrontend 命令参数
`--query-frontend.tenant-header`: 设置从 http request header 中哪个字段读取 tenant id.
`--query-frontend.tenant-certificate-field`: 使用 mTLS 认证, 从客户端证书的 O, OU, CN字段中获取 tenant id. 当该字段设置时, 不会再从 http request header 中获取 tenant id. 该参数目前处于 Hidden 状态.

## Coding
### func path.Base(path string) string
该函数来自 Go 标准库 `path`, 作用是返回路径字符串中 `basename`

## http.Request
`http.Request.TLS.PeerCertificates` 是证书链(leaf + intermediates), 如果这个字段有值, 那么 [0] 就一定是 leaf. 

## 加密通信
### TLS
TLS 中是单向身份验证, 只需要客户端验证服务端身份.
身份验证期间使用非对称加密
身份验证通过后使用协商一致的密钥, 通过对称加密进行通信
服务端: CA签发的证书

### mTLS
mTLS 是双向身份验证, 客户端要验证服务端, 服务端也需要验证客户端.
身份验证期间使用非对称加密
身份验证通过后使用协商一致的密钥, 通过对称加密进行通信

### 证书链
之所以存在证书链是因为证书颁发机构是层级机构, 从而形成信任链(证书链).

通常 CA 的分层签发体系如下:
| 层级 | 说明 |
| - | - |
| Leaf 证书(终端证书) | 是你用在服务器上的证书 |
| Intermediate CA | CA 签发出来的 "子 CA", 用于签发 leaf |
| Root CA | 顶层 CA, 预装在操作系统或浏览器中 |

而证书验证时也是从leaf开始一层一层的验证, 形成完整的信任链.

### 证书包含什么
证书的正式名称是 X.509 数字证书, 通常是 .crt 或 .pem 文件.
证书是用来表明身份的, 是公开的, 是可以发给任何人的.
```text
- 公钥 (Public Key)
- 颁发者信息 (Issuer = 哪个 CA)
- 使用者信息 (Subject = 域名/组织)
- 证书有效期 (notBefore, notAfter)
- 签名 (CA 对上述内容的签名)
- 可选字段 (SAN, 用途等)
```

### 疑问
#### 客户端证书中携带租户信息
客户端证书中怎么携带? 或者说我想要知道的还是如何生成证书, 就拿 openssl 实现.

1. 创建 Root CA
   ```bash
   # 创建 Root CA 私钥
   openssl genrsa -out rootCA.key 2048

   # 创建 Root CA 自签名证书
   openssl req -x509 -new -nodes -key rootCA,key -sha256 -days 3650 -out rootCA.crt \
   - subj "/C=CN/ST=Beijing/O=MyCorp/CN=MyRootCA"
   ```
2. 创建客户端私钥 & CSR(Certificate Signing Request, 证书签发请求)
   ```bash
   # 创建客户端私钥
   openssl genrsa -out client.key 2048

   # 创建带租户字段的 CSR(证书签发请求)
   openssl req -new -key client.key -out client.csr \
   -subj "/C=CN/ST=Beijing/O=tenant-123/OU=app-team/CN=client1"
   ```
3. 用 Root CA 签发客户端证书
   ```bash
   openssl x509 -req -in client.csr -CA rootCA.crt -CAkey rootCA.key \
   -CAcreateserial -out client.crt -days 365 -sha256
   ```
4. 验证证书内容
   ```bash
   openssl x509 -in client.crt -noout -text
   ```

`-subj` 中的字段是标准化且固定的, 顺序不强制要求，但标准推荐顺序是: C → ST → L → O → OU → CN.
| 字段缩写           | 含义                        | 示例值                    | 是否常用     |
| -------------- | ------------------------- | ---------------------- | -------- |
| `C`            | Country（国家）               | `C=CN`                 | ✅        |
| `ST`           | State（省/州）                | `ST=Beijing`           | ✅        |
| `L`            | Locality（城市）              | `L=Beijing`            | ✅        |
| `O`            | Organization（组织）          | `O=tenant-123`         | ✅        |
| `OU`           | Organizational Unit（组织单元） | `OU=dev-team`          | ✅        |
| `CN`           | Common Name（通用名）          | `CN=client1`           | ✅        |
| `emailAddress` | Email 地址                  | `emailAddress=a@b.com` | ⚠️ 兼容性一般 |


#### 证书和私钥是如何配合的
在服务端 TLS 中(普通 HTTPS)
服务端有:

server.crt ← Leaf 证书

server.key ← 私钥（与证书匹配）

客户端使用服务端提供的证书, 验证其身份;

客户端生成一个“预主密钥”, 用服务端公钥加密发过去;

只有服务端私钥能解密，完成共享密钥协商;

没有私钥，握手无法完成 ❌。

#### mTLS 中身份验证使用的是: 私钥签名 + 公钥验证签名（验签）
签名和加密是不一样的, 签名是确认信息是否被修改.

**Thanos QureyFrontend 允许通过 client.crt 中 O, OU, CN 传递租户ID**