## TODO
- [ ] queryrange.RequestResponse 包含 queryrange.Response 类型, RequestResponse 这个的作用是什么? 有哪个中间层处理响应的时候需要请求中的信息?
- [ ] 从上到下 context.Context 是怎样的? 答复: ctx 中包含的租户信息, 至少 SplitByInterval 中 DoRequests 中从 ctx 中提取了租户信息.
- [ ] context.Context 中携带的租户信息可以是租户列表?
## Source Code
- [ ] splitByInterval.Do
  - [x] splitQuery: 按时间窗口切分请求得到子请求列表
  - [ ] DoRequests:
  - [x] labelCodec.MergeResponse
    - [ ] pkg/store/labelpb


## Coding
### make([]T, len) V.S. make([]T, len, cap)
`make([]T, 10)` 创建了一个长度为10, 容量为10的切片且会将切片中每个元素都初始化0值, 内存将会分配好;
`make([]T, 0, 10)` 创建了一个长度为0, 容量为10的切片, 没有任何初始化操作, 内部预留了足够空间用于后续追加操作, 不会立即触发扩容;

`append` 是从len位置开始添加元素的.

这里我曾经犯过一个错误, 就是使用 `make([]T, 10)` 初始化一个切片后, 使用 `append` 添加数据, 结果添加到 len 之后. 要注意 `make` 与 `append` 的特性.

### sort.Strings(x []string)
对字符串切片进行升序排列(原址排序). 从 go 1.22 开始等价于 slices.Sort. 只不过 slices.Sort 支持范型.

### func sort.Sort(data sort.Interface)
接口类型必须为: 
```go
type Interface interface {
    Len() int
    Less(i, j int) bool // Sort 是升序还是降序取决于 Less 函数的实现, Less 是升序结果即为升序.
    Swap(i, j int)
}
```

### 阻塞通道
1. 通道关闭(关闭通道只是禁止写入)后的行为: 关闭后不能向通道中写入, 任何写入都会触发 panic. 但是关闭后, 可以继续读取, 直至数据全部读取完毕.


### 并发模式
| 对比维度       | Worker 池模型（模式 1）      | 信号量控制模型（模式 2）        |
| ---------- | --------------------- | -------------------- |
| **并发控制方式** | goroutine worker 数    | 缓冲 channel 限制数量      |
| **代码复杂度**  | 稍复杂，需要队列和 worker loop | 较简单，逻辑一目了然           |
| **资源调度**   | 稳定、长寿命 goroutine 重用   | 大量短命 goroutine 创建销毁  |
| **可扩展性**   | 高，适合动态添加任务            | 中，适合任务已知的场景          |
| **吞吐表现**   | 优于信号量模型（goroutine 重用） | goroutine 数量多，调度成本高  |
| **任务可控性**  | 更易实现优雅退出、超时取消         | 不易提前中断，需配合 `context` |
| **适用场景**   | 请求量大、长期运行型系统          | 简单任务处理、请求量不大         |
