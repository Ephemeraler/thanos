## 大致调用流程


## 函数调用
- runQueryFrontend (cmd/thanos/query_frontend.go)
  下述函数调用链是创建 http.RoundTripper, 逐层封装 RoundTrip 函数功能, 得到 roundTripper.
  - parseTransportConfiguration(cmd/thanos/query_frontend.go): 函数基于配置创建 http.Transport
  - NewDownstreamRoundTripper(internal/cortex/frontend/downstream_roundtripper.go): 函数封装 http.Transport, 创建  downstreamRoundTripper 其RoundTrip 实现重定向请求URL - downstreamRoundTripper
  - NewTripperware(pkg/queryfrontend/roundtrip.go): 
    函数内部会创建3个封装 downstreamRoundTripper 的 http.RoundTripper, 并创建 roundTrip 对象, 该对象中包含新创建的3个 http.RounfTripper 以及 downstreamRoundTripper. roundTrip.RoundTrip 根据请求资源类型匹配不同 http.RoundTripper 执行.
    - newRoundTripper(pkg/queryfrontend/roundtrip.go): 创建 roundTrip 对象.
      - InternalTenancyConversionTripper(pkg/tenancy/tenancy.go): 封装 roundTrip 对象, 返回 roundTripperFunc. roundTripperFunc.RoundTrip 就是调用 roundTripperFunc. roundTripperFunc 的具体实现是在请求头中设置 tenant.
    下述3个http.RoundTripper 封装 downstreamRoundTripper, 我猜测其封装想要实现的功能都是由 Middleware 实现的.
    - newQueryRangeTripperware(pkg/queryfrontend/roundtrip.go): 创建 
      - NewRoundTripper(internal/cortex/querier/queryrange/roundtrip.go): 创建 roundTripper, 
    - newInstantQueryTripperware(pkg/queryfrontend/roundtrip.go): 函数封装 
      - NewRoundTripper(internal/cortex/querier/queryrange/roundtrip.go)
    - newLabelsTripperware(pkg/queryfrontend/roundtrip.go)
      - NewRoundTripper(internal/cortex/querier/queryrange/roundtrip.go)

  下述函数使用上述封装的 roundTripper 处理请求.
  - NewHandler(internal/cortex/frontend/transport/handler.go)



### 先从 queryInstantRoundTripper 解读
- newInstantQueryTripperware: 创建 queryInstantRoundTripper(http.RoundTripper) 构造器
  创建中间层(以下按添加顺序说明)
  - InstrumentMiddleware(internal/cortex/querier/queryrange)
  - PromQLShardingMiddleware
  - NewStatsMiddleware(internal/cortex/querier/queryrange)
  创建 http.RoundTripper 构造器 
  - NewRoundTripper(internal/cortex/querier/queryrange)
    返回 roundTripper 对象.
  - RoundTripFunc(internal/cortex/querier/queryrange) 封装 roundTripper, 本质上其 RoundTrip 就是调用 roundTripper.RoundTrip


### 接下来解读 labelsRoundRripper 
- newLabelsTripperware: 创建 labelsRoundRripper(http.RoundTripper) 构造器
  创建中间层(以下按添加顺序说明)
  - InstrumentMiddleware(internal/cortex/querier/queryrange)
  - SplitByIntervalMiddleware
  - InstrumentMiddleware(internal/cortex/querier/queryrange)
  - NewResultsCacheMiddleware
  - InstrumentMiddleware
  - NewRetryMiddleware
  创建 http.RoundTripper 构造器
  - NewRoundTripper(internal/cortex/querier/queryrange)
    返回 roundTripper 对象.
  - RoundTripFunc(internal/cortex/querier/queryrange) 封装 roundTripper, 本质上其 RoundTrip 就是调用 roundTripper.RoundTrip

### 最后解读 queryRangeRoundTripper
- newQueryRangeTripperware: 创建 queryRangeRoundTripper(http.RoundTripper) 构造器

### roundTripper 类型(internal/cortex/querier/queryrange)
该类型是queryInstantRoundTripper, labelsRoundRripper, queryRangeRoundTripper. 只不过是通过 Middleware 来实现不同的功能.

这个函数就是 frontend handler 调用的函数. 在此函数下一层一层的调用.
roundTripper.RoundTrip
1. 将 http.Request 编码为 Request.
2. 使用 Request 作为参数调用 Handler.Do 发送请求. 
3. 将 Response 解码为 http.Response 返回.


中间层是 roundTripper.RoundTrip 的核心功能实现. 现在要搞懂中间层是如何工作的.

### Middleware 解读
看懂 Middleware 才能看懂上面 queryInstantRoundTripper, labelsRoundRripper, queryRangeRoundTripper 的构造.

在明确一下什么是中间层, 中间层函数就是将 Handler 封装后返回新 Handler.
而新 Handler 主要模板如下:
```
Do something

call old handler.Do

Do something
```

#### 以 queryInstantRoundTripper 构造时的中间层为例
##### 中间层类型
```go
// internal/cortext/querier/queryrange/query_range.go
type Request interface {
    GetStart() int64
    GetEnd() int64
    ...
}

// internal/cortext/querier/queryrange/query_range.go
type Response interface {
    ...
}

// internal/cortext/querier/queryrange/roundtrip.go
type Handler interface {
    Do(context.Context, Request) (Response, error)
}

// internal/cortext/querier/queryrange/roundtrip.go
type Middleware interface {
    Wrap(Handler) Handler
}

// MiddlewareFunc 是 Middleware 的具体实现.
type MiddlewareFunc func(Handler) Handler

func (q MiddlewareFunc) Wrap(h Handler) Handler {
	return q(h)
}

// HandlerFunc 是 Handler 的具体实现.
type HandlerFunc func(context.Context, Request) (Response, error)

func (q HandlerFunc) Do(ctx context.Context, req Request) (Response, error) {
	return q(ctx, req)
}
```

具体的, 中间层会根据添加的顺序逆序封装 Handler. 而最内层的 Handler 是 roundTripper 类型对象(internal/cortext/querier/queryrange/roundtrip.go)


## Coding
### Function Adapter(函数适配器模式)
```go
// 这样就把 HandlerFunc 具体实现动态化.
type HandlerFunc func(context.Context, Request) (Response, error)

func (q HandlerFunc) Do(ctx context.Context, req Request) (Response, error) {
	return q(ctx, req)
}
```
1. 接口适配器: 允许我们将普通函数"适配"为接口, 特别适用于中间件、处理器(handler)、回调等需要符合某个接口但我们又想用函数快速实现的场景.
2. 减少冗余代码: 避免创建额外的 struct 类型, 只会函数就可以满足接口要求.