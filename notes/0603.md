## 目标
搞清楚 Query Instant Codec 及对应 Request, Response 的参数

### RoundTripper(Query Instant请求为例)
0: tenantTripper(pkg/tenant/tenant.go)
1: rounteTrpper(pkg/queryfrontend/roundtrip.go): 根据请求数据类型分发下一层 Tripper.
2: queryInstantTripper(internal/cortex/querier/queryrange/roundtrip.go): 编码 Request(ThanosQueryInstantRequest), 调用中间层, 解码 Response(PrometheusInstantQueryResponse)
3: Middleware
    3.1: InstrumentMiddleware: 用于计时 sharding 操作耗时. 但是我不知道 stats 等中间层消耗的时间会不会被记录下来.
    3.2: ShardingMiddleware
    3.3: StatsMiddleware: 将响应中的 stats 累积统计到 context 中.
    3.4: queryInstantTripper.Do: 解码 Request, 调用 RoundTrip, 编码 Response.
5: downstreamTipper.RoundTrip: 
6: http.Transport.RoundTrip:

### Middleware 填加顺序与调用顺序
越晚添加越靠核心越近. 也就是先增加的 Middleware 会先调用.

### tenantTripper
从 request 中获取 tenant 信息, 来源为 Header、Certification. 当配置来源为 Certification 时, 无法获取 tenant 信息时, tenant 信息会设置为空.
当来源为 Header 时, 无法获取 tenant 时, 会设置默认 tenant 信息继续执行.
当成功获取 tenant 信息后, 删除 Header (若来源为此) 中 tenant 信息, 使用 `THANOS-TENANT:***` 重新设置请求头.

### Thanos Metrics
thanos_query_frontend_queries_total
  - op: query = query instant

### Query Instant Codec
1. 使用 ThanosQueryInstantRequest, PrometheusInstantQueryResponse 作为 Request, Response.

### Thanos HTTP API
#### 请求参数
- query: promql 语句
- dedup:
- partial_response:
- start: range query 的开始时间, unix_timestamp 格式.
- end: range query 的结束时间, unix_tempstamp 格式.
- step: range query 中时间序列的步长. duration 格式或 float 类型(秒)
- max_source_resolution: duration 格式或auto
- engine
- analyze
- tenant

### Prometheus HTTP API
#### 参数
1. unix_timestamp: 文本格式, 以秒为单位的 Unix 时间戳, 可选小数用于亚秒级精度.


### Coding
#### time.Duration
time.Duration 是以纳秒形式存储的.

#### .proto 文件
Protocol Buffers, protobuf 文件是 Google 提出的高效、可扩展序列化协议, 广泛用于微服务、gRPC、数据传输等场景.

常见序列化协议对比:
| 协议                             | 格式  | 可读性   | 大小   | 速度   | 特点                  |
| ------------------------------ | --- | ----- | ---- | ---- | ------------------- |
| **JSON**                       | 文本  | ✅ 可读  | ❌ 较大 | ❌ 慢  | 简单、通用、广泛支持          |
| **Protocol Buffers（protobuf）** | 二进制 | ❌ 不可读 | ✅ 小  | ✅ 快  | 高效、跨语言、需 .proto 定义  |
| **MessagePack**                | 二进制 | ❌     | ✅    | ✅    | JSON 的二进制形式         |
| **Avro**                       | 二进制 | ❌     | ✅    | ✅    | 支持 schema 演化        |
| **Thrift**                     | 二进制 | ❌     | ✅    | ✅    | 类似 protobuf，但集成更多工具 |
| **XML**                        | 文本  | ✅ 可读  | ❌ 最大 | ❌ 最慢 | 结构清晰，冗余大            |

.proto 文件的作用:
* 定义数据结构(message)
* 定义服务接口(service) 用于 gRPC
* 自动生成对应语言的代码
* 可用于高性能网络通信、配置存储、RPC 调用等.

message 生成后会有哪些方法:
* Getter: 返回字段值
* Reset(): 重置对象为0值/初始值.
* String(): 返回字符串表示(调试用).
* ProtoMessage(): 标记为 proto 消息类型.
* Descriptor(): 返回序列化的描述信息(新版废弃).
* Marshal(): 序列化
* Unmarshal():  反序列化
* Size(): 返回编码后的字节大小
* MarshalToSizedBuffer(): 


#### 函数类型实现接口
```go
type roundTripperFunc func(*http.Request) (*http.Response, error)

func (r roundTripperFunc) RoundTrip(request *http.Request) (*http.Response, error) {
	return r(request)
}
```
该编程技巧让函数本身充当一个接口的实现者, 非常适合简化某些中间件、装饰器、适配器的写法, 不需要冗长的 struct 定义.


#### tls.ConnectionState 中 PeerCertificates 字段
该字段存储的是 TLS 握手中对端(peer)所发送的证书链. PeerCertificates[0] 是 peer(对端)提供的"leaf certificate" (即实际使用的主证书)

#### x509.Certificate 中 Subject 字段
Subject 保存证书的身份信息.

#### func io.LimitReader(r io.Reader, n int64) io.Reader
返回一个 io.Reader，最多只能从原始 r 中读取 n 字节。读满 n 字节后就会返回 EOF

#### wall time
wall time 是指真实世界流逝的时间.

#### func atomic.LoadInt32(addr *int32) (val int32)
以原子方式读取某个 int32 类型变量的值，确保在并发环境下读取不会被中断或读取到不一致的值
LoadInt32 atomically loads *addr. Consider using the more ergonomic and less error-prone [Int32.Load] instead.
