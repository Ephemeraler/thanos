## 目标
Tripperware 是 http.RoundTripper, 接受与返回的是 http.Request 与 http.Response, 封装 RoundTrip 函数.
Middleware 是封装 Handler, 核心函数是 Do, 该函数接收与返回 Request, Reponse.
Query Instant Middleware 的作用

## Query Instant RoundTrip 层级
1. tenantRoundTripper: 统一 tenant id 在 thanos 中的传递方式.
2. routeRoundTripper: 根据请求资源分发到对应 RoundTripper, 本实例即 queryInstantRoundTripper.
3. queryInstantRoundTripper


### 创建 queryInstantRoundTripper
1. 传入参数
   - 垂直分片数量(--query-frontend.vertical-shards)
   - Limits(⚠️我不知道为什么传入的是queryrangelimits)
     - --query-range.max-query-length, 默认0, 限制 query-frontend 中查询的时间范围（end - start 时间），设置为 0 表示不限制
     - --query-range.max-query-parallelism, 默认14, Frontend 最多会并行调度的查询范围请求数量上限
     - --query-range.response-cache-max-freshness, 默认1m, 查询范围请求中允许被缓存的最新结果时间，用于防止缓存那些可能仍在变化中的非常新的结果.
   - Codec
   - prometheus.Registerer
   - forwardheaders(--query-frontend.forward-header)
   - querystatsenabled(--query-frontend.force-query-stats)

2. Middlerware (下述顺序为 middlewares 添加顺序)
   - InstrumentMiddleware 返回 Sharding Instrument Handler
   - PromQLShardingMiddleware
3. 

### MiddlerWare
是将 Handler 封装成新 Handler
1. InstrumentMiddleware 封装 Handler, 使用 prometheus.Histogram 记录 Handler 执行时间.

## Codec
### query instant codec - queryInstantCodec(pkg/queryfrontend/queryinstant_codec.go)
对应 Request: ThanosQueryInstantRequest(pkg/queryfrontend/request.go)
对应 Response: PrometheusInstantQueryResponse(internal/cortex/querier/queryrange/queryrange.pb.go)

### query range codec - queryRangeCodec(internal/queryfrontend/queryrange_codec.go)
对应 Request: ThanosQueryInstantRequest(pkg/queryfrontend/request.go)
对应 Response: PrometheusInstantQueryResponse(internal/cortex/querier/queryrange/queryrange.pb.go)

### labels codec - labelsCodec(pkg/queryfrontend/labels_codec.go)


## Coding
### prometheus registerer
func prometheus.WrapRegistererWith(labels prometheus.Labels, reg prometheus.Registerer) prometheus.Registerer
为注册到 reg 的所有指标打上固定的 label 标签

### func (f *kingpin.FlagClause) PlaceHolder(placeholder string) *kingpin.FlagClause
用于设置命令行帮助信息中参数的占位符的方法.
```go
app := kingpin.New("myapp", "An example application.")
app.Flag("config", "Path to configuration file").
    PlaceHolder("FILE").
    Default("/etc/myapp/config.yaml").
    String()
```

下述 FILE 就是占位符
```arduion
  --config=FILE   Path to configuration file (default: /etc/myapp/config.yaml)
```

1. 当没有占位符, 有默认值时, --config后显示默认值
2. 当没有占位符, 没有默认值时, --config=CONFIG 默认参数对应的string


### github.com/hashicorp/golang-lru/v2
该包用于管理 LRU, Least Recently Used 缓存.

### github.com/weaveworks/common/instrument
该包是 Weaveworks 提供的一个用于在服务中统一埋点、收集 Prometheus 指标的 Go 包, 常用于在 HTTP/gRPC 服务中对请求耗时、错误码等进行埋点统计.

1. func instrument.NewHistogramCollector(metric *prometheus.HistogramVec) *instrument.HistogramCollector
   返回一个 *HistogramCollector 实例，用于记录耗时的直方图数据.

   metric: 一个 Prometheus 的 HistogramVec 指针，通常是按 method、status_code 等标签定义的耗时直方图.


2. func instrument.CollectedRequest(ctx context.Context, method string, col instrument.Collector, toStatusCode func(error) string, f func(context.Context) error) error
   用于执行某个操作 f 的同时, 自动记录 f 执行耗时和状态码(通常用于请求处理的统一封装)


### func promauto.With(r prometheus.Registerer) promauto.Factory
用于创建一个自动注册（auto-registering）指标工厂，其所有创建的指标会自动注册到指定的 Registerer.

为什么用该函数?
对于中大型项目，它显著提升了开发体验和可维护性
```go
// 传统写法
reg := prometheus.NewRegistry()

myCounter := prometheus.NewCounter(prometheus.CounterOpts{
    Name: "my_counter",
    Help: "Help text",
})

reg.MustRegister(myCounter)
```

```go
// 使用 promauto
reg := prometheus.NewRegistry()

factory := promauto.With(reg)

myCounter := factory.NewCounter(prometheus.CounterOpts{
    Name: "my_counter",
    Help: "Help text",
})
```
